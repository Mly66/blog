"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[5905],{6262:(t,r)=>{r.A=(t,r)=>{const o=t.__vccOpts||t;for(const[t,n]of r)o[t]=n;return o}},4609:(t,r,o)=>{o.r(r),o.d(r,{comp:()=>d,data:()=>g});var n=o(641);const s={},d=(0,o(6262).A)(s,[["render",function(t,r){return(0,n.uX)(),(0,n.CE)("div",null,r[0]||(r[0]=[(0,n.Fv)('<h1 id="jvm" tabindex="-1"><a class="header-anchor" href="#jvm"><span>JVM</span></a></h1><h2 id="🔥-jvm-面试八股文" tabindex="-1"><a class="header-anchor" href="#🔥-jvm-面试八股文"><span><strong>🔥 JVM 面试八股文</strong></span></a></h2><hr><h3 id="_1️⃣-jvm-内存结构-🚀" tabindex="-1"><a class="header-anchor" href="#_1️⃣-jvm-内存结构-🚀"><span><strong>1️⃣ JVM 内存结构 🚀</strong></span></a></h3><p>✅ <strong>JVM 运行时数据区域</strong></p><table><thead><tr><th><strong>区域</strong></th><th><strong>作用</strong></th><th><strong>GC 影响</strong></th></tr></thead><tbody><tr><td><strong>程序计数器</strong></td><td>记录当前线程执行的字节码指令地址，线程私有</td><td>❌ 不会发生 OOM</td></tr><tr><td><strong>虚拟机栈</strong></td><td>方法执行时存储局部变量、操作数栈、动态链接等</td><td>⚠ 栈溢出 (<code>StackOverflowError</code>)</td></tr><tr><td><strong>本地方法栈</strong></td><td>存放 <code>native</code> 方法的调用栈信息</td><td>⚠ 可能导致 OOM</td></tr><tr><td><strong>堆</strong></td><td>存放对象实例，垃圾回收主要区域</td><td>✅ 受 GC 影响 (<code>OutOfMemoryError</code>)</td></tr><tr><td><strong>方法区（元空间）</strong></td><td>存储类信息、常量、静态变量、JIT 编译代码</td><td>✅ JDK8 及以上使用 <strong>元空间</strong></td></tr></tbody></table><p>✅ <strong>堆内存划分</strong></p><ul><li><strong>新生代（Young）</strong>：Eden（8）+ S0（1）+ S1（1），使用 <strong>标记-复制算法</strong>。</li><li><strong>老年代（Old）</strong>：存放存活时间长的对象，使用 <strong>标记-整理算法</strong>。</li></ul><p>✅ <strong>字符串常量池</strong></p><ul><li><strong>JDK7 及以前</strong>：位于方法区（永久代）。</li><li><strong>JDK8 及以后</strong>：位于堆内存，回收更高效。</li></ul><hr><h3 id="_2️⃣-jvm-对象创建-访问方式-🛠" tabindex="-1"><a class="header-anchor" href="#_2️⃣-jvm-对象创建-访问方式-🛠"><span><strong>2️⃣ JVM 对象创建 &amp; 访问方式 🛠</strong></span></a></h3><p>✅ <strong>对象创建过程</strong></p><ol><li><strong>类加载检查</strong>：先检查类是否已经加载（类信息存储在方法区）。</li><li><strong>分配内存</strong>： <ul><li><strong>指针碰撞</strong>（无内存碎片）。</li><li><strong>空闲列表</strong>（有内存碎片）。</li></ul></li><li><strong>内存分配安全性</strong>： <ul><li><strong>CAS + 重试</strong></li><li><strong>TLAB（Thread Local Allocation Buffer）</strong>：线程独享的小块堆内存。</li></ul></li><li><strong>初始化零值</strong>。</li><li><strong>设置对象头</strong>（哈希码、GC 分代年龄、锁信息等）。</li><li><strong>调用构造方法 <code>init()</code></strong>。</li></ol><p>✅ <strong>对象访问方式</strong></p><table><thead><tr><th><strong>方式</strong></th><th><strong>特点</strong></th><th><strong>优缺点</strong></th></tr></thead><tbody><tr><td><strong>句柄池</strong></td><td>通过句柄找到对象地址</td><td><strong>间接访问，修改对象地址时只需维护句柄池</strong></td></tr><tr><td><strong>直接指针</strong></td><td>直接存储对象地址</td><td><strong>访问速度更快</strong>（HotSpot 采用）</td></tr></tbody></table><hr><h3 id="_3️⃣-jvm-垃圾回收-gc-♻" tabindex="-1"><a class="header-anchor" href="#_3️⃣-jvm-垃圾回收-gc-♻"><span><strong>3️⃣ JVM 垃圾回收（GC）♻</strong></span></a></h3><p>✅ <strong>四种引用类型</strong></p><table><thead><tr><th><strong>引用类型</strong></th><th><strong>GC 影响</strong></th><th><strong>用途</strong></th></tr></thead><tbody><tr><td><strong>强引用</strong></td><td><strong>不会被回收</strong></td><td>普通对象引用</td></tr><tr><td><strong>软引用</strong></td><td>内存不足时回收</td><td><strong>缓存</strong></td></tr><tr><td><strong>弱引用</strong></td><td>GC 时回收</td><td><code>ThreadLocal</code></td></tr><tr><td><strong>虚引用</strong></td><td>仅用于监听对象回收</td><td><strong>管理直接内存</strong></td></tr></tbody></table><p>✅ <strong>对象可达性判断</strong></p><ul><li><strong>引用计数法（已淘汰）</strong>：无法解决循环引用问题。</li><li><strong>可达性分析算法（GC Roots）</strong>： <ul><li>栈帧局部变量</li><li>静态变量</li><li>类加载器</li><li><strong>JVM GC 采用此方法</strong></li></ul></li></ul><p>✅ <strong>GC 算法</strong></p><table><thead><tr><th><strong>GC 算法</strong></th><th><strong>特点</strong></th><th><strong>优缺点</strong></th></tr></thead><tbody><tr><td><strong>标记-清除</strong></td><td>标记存活对象，清除未标记对象</td><td><strong>容易产生内存碎片</strong></td></tr><tr><td><strong>标记-复制</strong></td><td>将存活对象复制到另一块区域</td><td><strong>浪费一半空间</strong></td></tr><tr><td><strong>标记-整理</strong></td><td>清理碎片，整理成连续空间</td><td><strong>适用于老年代</strong></td></tr><tr><td><strong>分代回收</strong></td><td>新生代（标记-复制）+ 老年代（标记-整理）</td><td><strong>优化垃圾回收效率</strong></td></tr></tbody></table><p>✅ <strong>垃圾回收器</strong></p><table><thead><tr><th><strong>GC</strong></th><th><strong>作用</strong></th><th><strong>特点</strong></th></tr></thead><tbody><tr><td><strong>Serial GC</strong></td><td>单线程，新生代（标记-复制）</td><td><strong>Stop The World（STW）</strong></td></tr><tr><td><strong>Parallel GC</strong></td><td>多线程，吞吐量优先</td><td><strong>JDK8 默认 GC</strong></td></tr><tr><td><strong>CMS GC</strong></td><td>老年代，并发标记清除</td><td><strong>低延迟，但有碎片</strong></td></tr><tr><td><strong>G1 GC</strong></td><td><strong>JDK9 默认 GC</strong>，分区回收</td><td><strong>低延迟 + 高吞吐</strong></td></tr></tbody></table><p>✅ <strong>STW（Stop The World）</strong></p><ul><li><strong>GC 时暂停所有用户线程</strong>，确保 GC 过程一致性。</li><li>G1 <strong>降低 STW 影响</strong>，通过<strong>增量式 GC</strong> 进行优化。</li></ul><hr><h3 id="_4️⃣-jvm-类加载机制-🔥" tabindex="-1"><a class="header-anchor" href="#_4️⃣-jvm-类加载机制-🔥"><span><strong>4️⃣ JVM 类加载机制 🔥</strong></span></a></h3><p>✅ <strong>类加载过程</strong></p><table><thead><tr><th><strong>阶段</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td><strong>加载</strong></td><td>读取 <code>.class</code> 文件，转换为 <code>Class</code> 对象</td></tr><tr><td><strong>连接</strong></td><td><strong>验证</strong>（校验字节码）、<strong>准备</strong>（分配静态变量内存）、<strong>解析</strong>（符号引用转为直接引用）</td></tr><tr><td><strong>初始化</strong></td><td>执行静态代码块 <code>clinit()</code></td></tr></tbody></table><p>✅ <strong>双亲委派模型</strong></p><ul><li><strong>加载顺序</strong>：<code>Bootstrap</code>（rt.jar） → <code>ExtClassLoader</code>（ext 目录） → <code>AppClassLoader</code>（classpath）</li><li><strong>作用</strong>：防止 <strong>核心 API 被篡改</strong>（如 <code>String</code> 类）。</li><li><strong>自定义类加载器</strong>： <ul><li><strong>不破坏双亲委派</strong>：继承 <code>ClassLoader</code>，重写 <code>findClass()</code>。</li><li><strong>打破双亲委派</strong>：重写 <code>loadClass()</code>。</li></ul></li></ul><p>✅ <strong>Tomcat 类加载机制</strong></p><ul><li><strong>每个 Web 应用有独立的类加载器</strong>，避免类冲突。</li><li><strong>打破双亲委派</strong>，优先加载 Web 应用中的类。</li></ul><hr><h3 id="_5️⃣-jvm-调优-🎯" tabindex="-1"><a class="header-anchor" href="#_5️⃣-jvm-调优-🎯"><span><strong>5️⃣ JVM 调优 🎯</strong></span></a></h3><p>✅ <strong>JVM 参数</strong></p><table><thead><tr><th><strong>参数</strong></th><th><strong>作用</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><code>-Xms</code></td><td><strong>初始堆大小</strong></td><td><code>-Xms2G</code></td></tr><tr><td><code>-Xmx</code></td><td><strong>最大堆大小</strong></td><td><code>-Xmx5G</code></td></tr><tr><td><code>-Xss</code></td><td><strong>每个线程栈大小</strong></td><td><code>-Xss256k</code></td></tr><tr><td><code>-XX:NewRatio</code></td><td><strong>新生代与老年代比例</strong></td><td><code>-XX:NewRatio=2</code></td></tr><tr><td><code>-XX:MetaspaceSize</code></td><td><strong>元空间初始大小</strong></td><td><code>-XX:MetaspaceSize=256m</code></td></tr></tbody></table><p>✅ <strong>GC 监控工具</strong></p><table><thead><tr><th><strong>工具</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td><code>jstack</code></td><td>查看线程堆栈</td></tr><tr><td><code>jmap</code></td><td>查看堆内存分布</td></tr><tr><td><code>jconsole</code></td><td>图形化查看 GC</td></tr><tr><td><strong>Arthas</strong></td><td>阿里开源 JVM 诊断神器</td></tr></tbody></table><p>✅ <strong>GC 调优策略</strong></p><ol><li><strong>避免创建过多对象</strong>（减少 GC 频率）。</li><li><strong>调整 GC 线程数</strong>（<code>-XX:ParallelGCThreads</code>）。</li><li><strong>使用 <code>intern()</code> 进行字符串池优化</strong>。</li><li><strong>减少 Full GC 触发频率</strong>（避免 <code>System.gc()</code>）。</li></ol><hr><h3 id="_6️⃣-其他-jvm-相关知识" tabindex="-1"><a class="header-anchor" href="#_6️⃣-其他-jvm-相关知识"><span><strong>6️⃣ 其他 JVM 相关知识</strong></span></a></h3><p>✅ <strong>Java 为什么能跨平台？</strong></p><ul><li><strong>JVM 是与平台相关的</strong>，不同平台的 JVM <strong>翻译 <code>.class</code> 文件</strong>，确保一次编译，处处运行。</li></ul><p>✅ <strong>JIT（即时编译器）优化</strong></p><table><thead><tr><th><strong>优化方式</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td><strong>缓存</strong></td><td><strong>热点代码缓存</strong>，提高执行效率</td></tr><tr><td><strong>逃逸分析</strong></td><td><strong>对象未逃出方法，直接在栈上分配</strong></td></tr><tr><td><strong>锁消除</strong></td><td><strong>移除不必要的锁</strong>，减少同步开销</td></tr></tbody></table><p>✅ <strong>如何判断两个类是否相同？</strong></p><ul><li><strong>类加载器不同，则类不同</strong>。</li></ul><hr><h3 id="🔥-总结" tabindex="-1"><a class="header-anchor" href="#🔥-总结"><span><strong>🔥 总结</strong></span></a></h3><p>1️⃣ <strong>JVM 运行时数据区 &amp; 内存分配机制</strong>。<br> 2️⃣ <strong>GC 机制 &amp; JVM 调优策略</strong>。<br> 3️⃣ <strong>类加载过程 &amp; 双亲委派模型</strong>。<br> 4️⃣ <strong>JIT 编译优化 &amp; 逃逸分析</strong>。<br> 5️⃣ <strong>GC 监控工具 &amp; 调优方法</strong>。</p>',55)]))}]]),g=JSON.parse('{"path":"/posts/interview/JVM.html","title":"JVM","lang":"zh-CN","frontmatter":{"icon":"pen-to-square","date":"2024-03-25T00:00:00.000Z","category":["面试"],"tag":["JVM"],"description":"JVM 🔥 JVM 面试八股文 1️⃣ JVM 内存结构 🚀 ✅ JVM 运行时数据区域 ✅ 堆内存划分 新生代（Young）：Eden（8）+ S0（1）+ S1（1），使用 标记-复制算法。 老年代（Old）：存放存活时间长的对象，使用 标记-整理算法。 ✅ 字符串常量池 JDK7 及以前：位于方法区（永久代）。 JDK8 及以后：位于堆内存，...","head":[["meta",{"property":"og:url","content":"https://github.com/Mly66/blog/posts/interview/JVM.html"}],["meta",{"property":"og:site_name","content":"马瑶瑶瑶瑶瑶"}],["meta",{"property":"og:title","content":"JVM"}],["meta",{"property":"og:description","content":"JVM 🔥 JVM 面试八股文 1️⃣ JVM 内存结构 🚀 ✅ JVM 运行时数据区域 ✅ 堆内存划分 新生代（Young）：Eden（8）+ S0（1）+ S1（1），使用 标记-复制算法。 老年代（Old）：存放存活时间长的对象，使用 标记-整理算法。 ✅ 字符串常量池 JDK7 及以前：位于方法区（永久代）。 JDK8 及以后：位于堆内存，..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-25T02:50:16.000Z"}],["meta",{"property":"article:tag","content":"JVM"}],["meta",{"property":"article:published_time","content":"2024-03-25T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-25T02:50:16.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"JVM\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-03-25T00:00:00.000Z\\",\\"dateModified\\":\\"2025-03-25T02:50:16.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.Mly\\",\\"url\\":\\"https://mly66.github.io/blog/\\"}]}"]]},"headers":[{"level":2,"title":"🔥 JVM 面试八股文","slug":"🔥-jvm-面试八股文","link":"#🔥-jvm-面试八股文","children":[{"level":3,"title":"1️⃣ JVM 内存结构 🚀","slug":"_1️⃣-jvm-内存结构-🚀","link":"#_1️⃣-jvm-内存结构-🚀","children":[]},{"level":3,"title":"2️⃣ JVM 对象创建 & 访问方式 🛠","slug":"_2️⃣-jvm-对象创建-访问方式-🛠","link":"#_2️⃣-jvm-对象创建-访问方式-🛠","children":[]},{"level":3,"title":"3️⃣ JVM 垃圾回收（GC）♻","slug":"_3️⃣-jvm-垃圾回收-gc-♻","link":"#_3️⃣-jvm-垃圾回收-gc-♻","children":[]},{"level":3,"title":"4️⃣ JVM 类加载机制 🔥","slug":"_4️⃣-jvm-类加载机制-🔥","link":"#_4️⃣-jvm-类加载机制-🔥","children":[]},{"level":3,"title":"5️⃣ JVM 调优 🎯","slug":"_5️⃣-jvm-调优-🎯","link":"#_5️⃣-jvm-调优-🎯","children":[]},{"level":3,"title":"6️⃣ 其他 JVM 相关知识","slug":"_6️⃣-其他-jvm-相关知识","link":"#_6️⃣-其他-jvm-相关知识","children":[]},{"level":3,"title":"🔥 总结","slug":"🔥-总结","link":"#🔥-总结","children":[]}]}],"git":{"createdTime":1742871016000,"updatedTime":1742871016000,"contributors":[{"name":"Mly66","email":"3127328609@qq.com","commits":1}]},"readingTime":{"minutes":4.31,"words":1293},"filePathRelative":"posts/interview/JVM.md","localizedDate":"2024年3月25日","excerpt":"\\n<h2><strong>🔥 JVM 面试八股文</strong></h2>\\n<hr>\\n<h3><strong>1️⃣ JVM 内存结构 🚀</strong></h3>\\n<p>✅ <strong>JVM 运行时数据区域</strong></p>\\n<table>\\n<thead>\\n<tr>\\n<th><strong>区域</strong></th>\\n<th><strong>作用</strong></th>\\n<th><strong>GC 影响</strong></th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td><strong>程序计数器</strong></td>\\n<td>记录当前线程执行的字节码指令地址，线程私有</td>\\n<td>❌ 不会发生 OOM</td>\\n</tr>\\n<tr>\\n<td><strong>虚拟机栈</strong></td>\\n<td>方法执行时存储局部变量、操作数栈、动态链接等</td>\\n<td>⚠ 栈溢出 (<code>StackOverflowError</code>)</td>\\n</tr>\\n<tr>\\n<td><strong>本地方法栈</strong></td>\\n<td>存放 <code>native</code> 方法的调用栈信息</td>\\n<td>⚠ 可能导致 OOM</td>\\n</tr>\\n<tr>\\n<td><strong>堆</strong></td>\\n<td>存放对象实例，垃圾回收主要区域</td>\\n<td>✅ 受 GC 影响 (<code>OutOfMemoryError</code>)</td>\\n</tr>\\n<tr>\\n<td><strong>方法区（元空间）</strong></td>\\n<td>存储类信息、常量、静态变量、JIT 编译代码</td>\\n<td>✅ JDK8 及以上使用 <strong>元空间</strong></td>\\n</tr>\\n</tbody>\\n</table>","autoDesc":true}')}}]);
"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[1681],{6262:(s,t)=>{t.A=(s,t)=>{const r=s.__vccOpts||s;for(const[s,n]of t)r[s]=n;return r}},6610:(s,t,r)=>{r.r(t),r.d(t,{comp:()=>e,data:()=>g});var n=r(641);const o={},e=(0,r(6262).A)(o,[["render",function(s,t){return(0,n.uX)(),(0,n.CE)("div",null,t[0]||(t[0]=[(0,n.Fv)('<h1 id="redis" tabindex="-1"><a class="header-anchor" href="#redis"><span>Redis</span></a></h1><h2 id="redis-面试八股知识点总结-💡" tabindex="-1"><a class="header-anchor" href="#redis-面试八股知识点总结-💡"><span>Redis 面试八股知识点总结 💡</span></a></h2><h3 id="_1️⃣-redis-的-5-3-种基本数据结构-📦" tabindex="-1"><a class="header-anchor" href="#_1️⃣-redis-的-5-3-种基本数据结构-📦"><span>1️⃣ <strong>Redis 的 5+3 种基本数据结构 📦</strong></span></a></h3><p>✅ <strong>String</strong>（字符串） 📌 <strong>应用场景</strong>：缓存 <code>session</code>、<code>token</code>、限流、分布式锁、计数器</p><p>✅ <strong>List</strong>（列表） 📌 <strong>应用场景</strong>：消息队列（<code>LPUSH + BRPOP</code>）、时间线</p><p>✅ <strong>Hash</strong>（哈希表） 📌 <strong>应用场景</strong>：用户信息、购物车、对象存储</p><p>✅ <strong>Set</strong>（集合） 📌 <strong>应用场景</strong>：<strong>去重</strong>（点赞、共同好友、标签）</p><p>✅ <strong>ZSet</strong>（有序集合） 📌 <strong>应用场景</strong>：排行榜、延迟队列</p><p>💡 <strong>扩展数据结构</strong>： ✅ <strong>Bitmap</strong>：用户签到、活跃用户统计 ✅ <strong>HyperLogLog</strong>：UV 统计（节省内存但有误差） ✅ <strong>GEO</strong>：地理位置存储（查找附近的人）</p><hr><h3 id="_2️⃣-redis-如何实现高性能-🚀" tabindex="-1"><a class="header-anchor" href="#_2️⃣-redis-如何实现高性能-🚀"><span>2️⃣ <strong>Redis 如何实现高性能？🚀</strong></span></a></h3><p>✅ <strong>内存存储</strong>：所有数据都存储在 <strong>内存</strong> 中，读写速度极快（纳秒级别）。 ✅ <strong>单线程</strong>：避免 <strong>多线程加锁</strong> 造成的上下文切换开销。 ✅ <strong>IO 多路复用</strong>：基于 <strong>Reactor 模式</strong>，同时处理多个连接的请求。 ✅ <strong>Redis 6.0+</strong> 引入 <strong>多线程</strong>，优化 <strong>网络 IO</strong>（命令解析 &amp; 响应回写）。</p><p>❓ <strong>为什么 Redis6.0 之前不采用多线程？</strong> 📌 Redis 的瓶颈主要在 <strong>网络 IO</strong>，而不是 CPU 计算。</p><hr><h3 id="_3️⃣-redis-过期删除策略-⏳" tabindex="-1"><a class="header-anchor" href="#_3️⃣-redis-过期删除策略-⏳"><span>3️⃣ <strong>Redis 过期删除策略 ⏳</strong></span></a></h3><p>✅ <strong>过期删除</strong>（两种策略）</p><ul><li><strong>定时删除</strong>（定期扫描 &amp; 批量删除，但占用 CPU 资源）。</li><li><strong>惰性删除</strong>（访问时检查过期，不会主动删除，可能占用内存）。</li></ul><p>✅ <strong>内存淘汰策略</strong>（内存不足时启用） 📌 <strong>常见策略</strong>（适用于 <strong>设置了过期时间</strong> 的键）：</p><ul><li><strong>TTL</strong>（最近即将过期的先删除 ⏳）</li><li><strong>LRU</strong>（最近最少使用的优先删除 🕰️）</li><li><strong>LFU</strong>（最少访问的优先删除 📉）</li><li><strong>RANDOM</strong>（随机删除 🎲）</li></ul><hr><h3 id="_4️⃣-redis-分布式锁-🔒" tabindex="-1"><a class="header-anchor" href="#_4️⃣-redis-分布式锁-🔒"><span>4️⃣ <strong>Redis 分布式锁 🔒</strong></span></a></h3><p>✅ <strong>基于 <code>SETNX + EXPIRE</code> 实现</strong>（简单但有问题 ❌） ❌ <strong>锁过期 &amp; 误删问题</strong>：业务超时，锁过期被其他线程获取，原线程执行完后释放的是别人的锁。 ✅ <strong>优化方案</strong>： 📌 1. <strong>给锁加唯一标识</strong>（避免误删） 📌 2. <strong>使用 Lua 脚本</strong>（保证解锁的原子性）</p><p>✅ <strong>Redisson 分布式锁</strong>（推荐 ✅） 📌 <strong>特性</strong>：可重入、自动续期（watchdog 机制）、支持锁重试、基于 Lua 脚本保证原子性。</p><p>✅ <strong>Zookeeper 分布式锁</strong> 📌 <strong>基于</strong> <strong>临时顺序节点</strong> + <strong>Watcher 机制</strong>，避免自旋等待，提高锁的公平性。</p><p>✅ <strong>RedLock（Redis 多节点分布式锁）</strong> 📌 <strong>用于 Redis 单点故障的情况下</strong>，但不能完全避免锁失效问题。</p><hr><h3 id="_5️⃣-redis-生产环境问题-🛠️" tabindex="-1"><a class="header-anchor" href="#_5️⃣-redis-生产环境问题-🛠️"><span>5️⃣ <strong>Redis 生产环境问题 🛠️</strong></span></a></h3><p>✅ <strong>缓存穿透 🚨</strong> 📌 <strong>问题</strong>：查询数据库 &amp; Redis <strong>都没有</strong> 该数据，导致请求直接打到数据库，影响性能。 📌 <strong>解决方案</strong>：</p><ul><li>参数校验 ❌ 非法请求直接拦截。</li><li><strong>缓存空值</strong>（<code>value = null</code>），避免重复查询数据库。</li><li><strong>布隆过滤器</strong>（BloomFilter），高效判断 Key 是否存在。</li></ul><p>✅ <strong>缓存雪崩 ❄️</strong> 📌 <strong>问题</strong>：大量 Key <strong>同时过期</strong>，请求打爆数据库。 📌 <strong>解决方案</strong>：</p><ul><li><strong>过期时间加随机值</strong>（防止集中失效）。</li><li><strong>Redis 集群</strong>，避免单点故障。</li></ul><p>✅ <strong>缓存击穿 💥</strong> 📌 <strong>问题</strong>：某个 <strong>热点 Key</strong> 失效，大量请求瞬间打爆数据库。 📌 <strong>解决方案</strong>：</p><ul><li><strong>互斥锁（加锁查询）</strong>。</li><li><strong>设置热点 Key 永不过期</strong>，手动删除。</li></ul><p>✅ <strong>BigKey &amp; 热点 Key</strong> 📌 <strong>问题</strong>：大 Key 影响查询 &amp; 删除性能；热点 Key 影响集群均衡。 📌 <strong>解决方案</strong>：</p><ul><li><strong>拆分大 Key</strong>（List 拆分多个小 Key）。</li><li><strong>热点 Key 进行多级缓存（本地缓存/CDN/Redis Cluster）</strong>。</li></ul><p>✅ <strong>数据一致性问题 🔄</strong> 📌 <strong>问题</strong>：MySQL &amp; Redis <strong>数据不一致</strong>（延迟更新问题）。 📌 <strong>解决方案</strong>：</p><ul><li><strong>先更新数据库，再删除缓存</strong>（避免并发问题）。</li><li><strong>延时双删策略</strong>（删除缓存 -&gt; 更新数据库 -&gt; 等待 -&gt; 再次删除缓存）。</li><li><strong>MQ + Canal 监听 MySQL Binlog</strong>，实现缓存同步。</li></ul><hr><h3 id="_6️⃣-redis-持久化机制-📝" tabindex="-1"><a class="header-anchor" href="#_6️⃣-redis-持久化机制-📝"><span>6️⃣ <strong>Redis 持久化机制 📝</strong></span></a></h3><p>✅ <strong>RDB（快照持久化）</strong> 📌 <strong>原理</strong>：周期性地将 <strong>整个 Redis 数据快照</strong> 持久化到磁盘。 📌 <strong>优点</strong>：文件小、恢复快。 📌 <strong>缺点</strong>：<strong>可能丢失最近一次快照后的数据</strong>。</p><p>✅ <strong>AOF（Append-Only File）</strong> 📌 <strong>原理</strong>：<strong>记录所有写操作</strong>，可重放日志恢复数据。 📌 <strong>优点</strong>：数据更安全，最多丢失 1 秒数据。 📌 <strong>缺点</strong>：<strong>日志文件较大，恢复速度较慢</strong>。</p><p>✅ <strong>选择方案</strong> 📌 <strong>高性能但允许数据丢失</strong>：RDB ✅ 📌 <strong>数据安全但影响性能</strong>：AOF ✅ 📌 <strong>最佳方案</strong>：<strong>RDB + AOF 结合使用</strong>。</p><hr><h3 id="_7️⃣-redis-事务-lua-脚本-⚡" tabindex="-1"><a class="header-anchor" href="#_7️⃣-redis-事务-lua-脚本-⚡"><span>7️⃣ <strong>Redis 事务 &amp; Lua 脚本 ⚡</strong></span></a></h3><p>✅ <strong>Redis 事务</strong>（<code>MULTI</code> + <code>EXEC</code>） 📌 <strong>缺点</strong>：<strong>不支持回滚</strong>，只保证命令的<strong>顺序执行</strong>。</p><p>✅ <strong>Lua 脚本</strong>（<strong>推荐！</strong>） 📌 <strong>优点</strong>：</p><ul><li><strong>原子操作</strong>（Redis 一次执行完整的 Lua 脚本）。</li><li><strong>减少网络开销</strong>（多个命令打包执行）。</li></ul><hr><h3 id="_8️⃣-redis-集群-🏢" tabindex="-1"><a class="header-anchor" href="#_8️⃣-redis-集群-🏢"><span>8️⃣ <strong>Redis 集群 🏢</strong></span></a></h3><p>✅ <strong>主从复制（Master-Slave）</strong> 📌 <strong>主库负责写入，从库负责读取</strong>（适合读多写少场景）。</p><p>✅ <strong>哨兵模式（Sentinel）</strong> 📌 <strong>自动监控 Redis 状态，主库宕机自动切换从库</strong>。</p><p>✅ <strong>Redis Cluster（推荐！）</strong> 📌 <strong>采用数据分片（哈希槽）</strong>，将数据存储到不同的节点，实现 <strong>高可用 &amp; 可扩展性</strong>。</p><hr><h3 id="_9️⃣-redis-延迟队列-滑动窗口限流-📊" tabindex="-1"><a class="header-anchor" href="#_9️⃣-redis-延迟队列-滑动窗口限流-📊"><span>9️⃣ <strong>Redis 延迟队列 &amp; 滑动窗口限流 📊</strong></span></a></h3><p>✅ <strong>延迟队列</strong>（基于 <code>ZSet</code>） 📌 <strong>用 <code>ZADD</code> 记录任务时间，定时轮询 <code>ZRANGEBYSCORE</code> 取出任务。</strong></p><p>✅ <strong>滑动窗口限流</strong>（基于 <code>ZSet</code>） 📌 <strong>记录时间戳，每次请求时移除超出窗口范围的数据，统计剩余请求数。</strong></p><hr><p>🎯 <strong>总结：Redis 面试重点关注</strong>：高性能机制、数据一致性、分布式锁、持久化、集群架构、缓存优化！ 🚀</p>',58)]))}]]),g=JSON.parse('{"path":"/posts/interview/Redis.html","title":"Redis","lang":"zh-CN","frontmatter":{"icon":"pen-to-square","date":"2024-03-11T00:00:00.000Z","category":["面试"],"tag":["Redis"],"description":"Redis Redis 面试八股知识点总结 💡 1️⃣ Redis 的 5+3 种基本数据结构 📦 ✅ String（字符串） 📌 应用场景：缓存 session、token、限流、分布式锁、计数器 ✅ List（列表） 📌 应用场景：消息队列（LPUSH + BRPOP）、时间线 ✅ Hash（哈希表） 📌 应用场景：用户信息、购物车、对象...","head":[["meta",{"property":"og:url","content":"https://github.com/Mly66/blog/posts/interview/Redis.html"}],["meta",{"property":"og:site_name","content":"马瑶瑶瑶瑶瑶"}],["meta",{"property":"og:title","content":"Redis"}],["meta",{"property":"og:description","content":"Redis Redis 面试八股知识点总结 💡 1️⃣ Redis 的 5+3 种基本数据结构 📦 ✅ String（字符串） 📌 应用场景：缓存 session、token、限流、分布式锁、计数器 ✅ List（列表） 📌 应用场景：消息队列（LPUSH + BRPOP）、时间线 ✅ Hash（哈希表） 📌 应用场景：用户信息、购物车、对象..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-11T13:47:23.000Z"}],["meta",{"property":"article:tag","content":"Redis"}],["meta",{"property":"article:published_time","content":"2024-03-11T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-11T13:47:23.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Redis\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-03-11T00:00:00.000Z\\",\\"dateModified\\":\\"2025-03-11T13:47:23.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.Mly\\",\\"url\\":\\"https://mly66.github.io/blog/\\"}]}"]]},"headers":[{"level":2,"title":"Redis 面试八股知识点总结 💡","slug":"redis-面试八股知识点总结-💡","link":"#redis-面试八股知识点总结-💡","children":[{"level":3,"title":"1️⃣ Redis 的 5+3 种基本数据结构 📦","slug":"_1️⃣-redis-的-5-3-种基本数据结构-📦","link":"#_1️⃣-redis-的-5-3-种基本数据结构-📦","children":[]},{"level":3,"title":"2️⃣ Redis 如何实现高性能？🚀","slug":"_2️⃣-redis-如何实现高性能-🚀","link":"#_2️⃣-redis-如何实现高性能-🚀","children":[]},{"level":3,"title":"3️⃣ Redis 过期删除策略 ⏳","slug":"_3️⃣-redis-过期删除策略-⏳","link":"#_3️⃣-redis-过期删除策略-⏳","children":[]},{"level":3,"title":"4️⃣ Redis 分布式锁 🔒","slug":"_4️⃣-redis-分布式锁-🔒","link":"#_4️⃣-redis-分布式锁-🔒","children":[]},{"level":3,"title":"5️⃣ Redis 生产环境问题 🛠️","slug":"_5️⃣-redis-生产环境问题-🛠️","link":"#_5️⃣-redis-生产环境问题-🛠️","children":[]},{"level":3,"title":"6️⃣ Redis 持久化机制 📝","slug":"_6️⃣-redis-持久化机制-📝","link":"#_6️⃣-redis-持久化机制-📝","children":[]},{"level":3,"title":"7️⃣ Redis 事务 & Lua 脚本 ⚡","slug":"_7️⃣-redis-事务-lua-脚本-⚡","link":"#_7️⃣-redis-事务-lua-脚本-⚡","children":[]},{"level":3,"title":"8️⃣ Redis 集群 🏢","slug":"_8️⃣-redis-集群-🏢","link":"#_8️⃣-redis-集群-🏢","children":[]},{"level":3,"title":"9️⃣ Redis 延迟队列 & 滑动窗口限流 📊","slug":"_9️⃣-redis-延迟队列-滑动窗口限流-📊","link":"#_9️⃣-redis-延迟队列-滑动窗口限流-📊","children":[]}]}],"git":{"createdTime":1741700843000,"updatedTime":1741700843000,"contributors":[{"name":"Mly66","email":"3127328609@qq.com","commits":1}]},"readingTime":{"minutes":4.36,"words":1308},"filePathRelative":"posts/interview/Redis.md","localizedDate":"2024年3月11日","excerpt":"\\n<h2>Redis 面试八股知识点总结 💡</h2>\\n<h3>1️⃣ <strong>Redis 的 5+3 种基本数据结构 📦</strong></h3>\\n<p>✅ <strong>String</strong>（字符串）\\n📌 <strong>应用场景</strong>：缓存 <code>session</code>、<code>token</code>、限流、分布式锁、计数器</p>\\n<p>✅ <strong>List</strong>（列表）\\n📌 <strong>应用场景</strong>：消息队列（<code>LPUSH + BRPOP</code>）、时间线</p>\\n<p>✅ <strong>Hash</strong>（哈希表）\\n📌 <strong>应用场景</strong>：用户信息、购物车、对象存储</p>","autoDesc":true}')}}]);
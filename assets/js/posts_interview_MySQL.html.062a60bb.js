"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[1852],{6262:(n,s)=>{s.A=(n,s)=>{const e=n.__vccOpts||n;for(const[n,t]of s)e[n]=t;return e}},2324:(n,s,e)=>{e.r(s),e.d(s,{comp:()=>r,data:()=>i});var t=e(641);const o={},r=(0,e(6262).A)(o,[["render",function(n,s){return(0,t.uX)(),(0,t.CE)("div",null,s[0]||(s[0]=[(0,t.Fv)('<h1 id="mysql" tabindex="-1"><a class="header-anchor" href="#mysql"><span>MySQL</span></a></h1><h2 id="mysql-面试八股知识点总结-💡" tabindex="-1"><a class="header-anchor" href="#mysql-面试八股知识点总结-💡"><span>MySQL 面试八股知识点总结 💡</span></a></h2><h3 id="_1️⃣-mysql-底层架构" tabindex="-1"><a class="header-anchor" href="#_1️⃣-mysql-底层架构"><span>1️⃣ <strong>MySQL 底层架构</strong></span></a></h3><p>✅ <strong>存储结构</strong>：MySQL 分为 <strong>Server 层</strong> 和 <strong>存储引擎层</strong>，其中 InnoDB 将表结构、数据和索引存储在同一个文件，而 MyISAM 则是分开存储。 ✅ <strong>存储引擎</strong>：</p><ul><li><strong>InnoDB</strong>：支持事务（ACID），行级锁，支持外键，使用 <strong>B+ 树</strong> 实现索引，崩溃后可恢复。</li><li><strong>MyISAM</strong>：不支持事务，仅支持表级锁，查询快但不支持数据恢复。</li><li><strong>Memory</strong>：数据存储在内存中，重启即丢失，适用于临时数据存储。</li></ul><hr><h3 id="_2️⃣-索引-index-🚀" tabindex="-1"><a class="header-anchor" href="#_2️⃣-索引-index-🚀"><span>2️⃣ <strong>索引（Index）🚀</strong></span></a></h3><p>✅ <strong>索引的优缺点</strong></p><ul><li>✅ <strong>优点</strong>：提升查询速度，减少 IO，优化排序（<code>ORDER BY</code>）和分组（<code>GROUP BY</code>），确保数据唯一性。</li><li>❌ <strong>缺点</strong>：增删改时需要维护索引，影响写入性能，占用额外存储空间。</li></ul><p>✅ <strong>索引类型</strong></p><ul><li><strong>主键索引</strong>（Primary Key）：唯一且不为空，InnoDB 默认使用 <strong>聚簇索引</strong>。</li><li><strong>普通索引</strong>（Index）：可以重复，可以为空。</li><li><strong>唯一索引</strong>（Unique）：不能重复，但可以为空。</li><li><strong>联合索引</strong>（Composite Index）：多个字段组成的索引，遵循 <strong>最左前缀匹配原则</strong>。</li><li><strong>覆盖索引</strong>（Covering Index）：查询的数据<strong>全部在索引中</strong>，不需要回表，提高查询效率。</li></ul><p>✅ <strong>B+ 树索引 vs. Hash 索引</strong></p><ul><li><strong>B+ 树</strong>：支持范围查询（<code>BETWEEN</code>）、排序（<code>ORDER BY</code>），稳定性高，InnoDB 默认使用。</li><li><strong>Hash</strong>：查询快但不支持范围查询，适用于 <strong>等值查询</strong>。</li></ul><p>✅ <strong>最左前缀匹配原则 🔍</strong></p><blockquote><p>联合索引 (<code>a, b, c</code>) 的使用顺序必须从左往右，否则索引可能失效！</p></blockquote><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>sql复制编辑SELECT * FROM table WHERE a = 1 AND b = 2; -- 走索引 ✅</span></span>\n<span class="line"><span>SELECT * FROM table WHERE b = 2; -- 索引失效 ❌</span></span>\n<span class="line"><span>SELECT * FROM table WHERE a = 1 AND b &gt; 2 AND c = 3; -- c 不走索引 ❌</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>✅ <strong>索引失效的情况</strong> 🚨 ❌ <code>LIKE &#39;%xx&#39;</code>（左模糊） ❌ <code>!=</code>、<code>IS NOT NULL</code> ❌ 在索引列上进行计算或函数操作 ❌ <code>OR</code> 语句中有非索引列 ❌ <strong>优化器认为全表扫描更快</strong>（小表情况）</p><hr><h3 id="_3️⃣-sql-执行流程与优化" tabindex="-1"><a class="header-anchor" href="#_3️⃣-sql-执行流程与优化"><span>3️⃣ <strong>SQL 执行流程与优化</strong></span></a></h3><p>✅ <strong>SQL 执行架构</strong>： 1️⃣ <strong>连接器</strong>（用户身份认证） 2️⃣ <strong>查询缓存</strong>（MySQL 8.0 以后移除） 3️⃣ <strong>解析器</strong>（SQL 语法分析） 4️⃣ <strong>优化器</strong>（选择最优执行计划） 5️⃣ <strong>执行器</strong>（调用存储引擎接口）</p><p>✅ <strong>查看 SQL 执行计划</strong></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>sql</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>复制编辑</span></span>\n<span class="line"><span>EXPLAIN SELECT * FROM table WHERE id = 1;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>type</code>：查询类型（<code>const</code> &gt; <code>ref</code> &gt; <code>range</code> &gt; <code>index</code> &gt; <code>ALL</code>）</li><li><code>key</code>：实际使用的索引</li><li><code>Extra</code>：索引优化情况（<code>Using index</code>、<code>Using where</code> 等）</li></ul><p>✅ <strong>SQL 优化技巧 🛠</strong> 🔥 <strong>避免 <code>SELECT \\*</code>，只查询需要的列</strong> 🔥 <strong>索引字段避免计算和函数</strong> 🔥 <strong>小表驱动大表，优化 JOIN</strong> 🔥 <strong>使用 <code>EXPLAIN</code> 分析执行计划，避免 <code>ALL</code> 全表扫描</strong> 🔥 <strong>分库分表、读写分离、引入 Redis 缓存</strong></p><hr><h3 id="_4️⃣-事务-transaction-⚡" tabindex="-1"><a class="header-anchor" href="#_4️⃣-事务-transaction-⚡"><span>4️⃣ <strong>事务（Transaction）⚡</strong></span></a></h3><p>✅ <strong>ACID 四大特性</strong></p><ul><li><strong>A</strong>（原子性）：要么全部执行，要么全部回滚（<code>Undo Log</code> 负责）。</li><li><strong>C</strong>（一致性）：事务开始前后，数据必须保持一致。</li><li><strong>I</strong>（隔离性）：并发事务之间互不影响（MVCC、锁机制）。</li><li><strong>D</strong>（持久性）：事务提交后数据不会丢失（<code>Redo Log</code> 负责）。</li></ul><p>✅ <strong>事务隔离级别 📌</strong>（从低到高） 1️⃣ 读未提交（Read Uncommitted）❌（可能出现脏读） 2️⃣ 读已提交（Read Committed）✅（SQL Server 默认，可能出现不可重复读） 3️⃣ 可重复读（Repeatable Read）✅（MySQL 默认，可能出现幻读） 4️⃣ 串行化（Serializable）🚫（最严格，但性能最差）</p><p>✅ <strong>快照读 vs. 当前读</strong></p><ul><li><strong>快照读</strong>（普通 <code>SELECT</code>）：不会加锁，采用 <strong>MVCC</strong> 实现。</li><li><strong>当前读</strong>（<code>SELECT ... FOR UPDATE</code>）：读取最新数据，并加锁防止修改。</li></ul><hr><h3 id="_5️⃣-mysql-锁-🔒" tabindex="-1"><a class="header-anchor" href="#_5️⃣-mysql-锁-🔒"><span>5️⃣ <strong>MySQL 锁 🔒</strong></span></a></h3><p>✅ <strong>表锁 vs. 行锁</strong></p><ul><li><strong>表锁</strong>：锁整张表，影响并发性能（MyISAM 仅支持表锁）。</li><li><strong>行锁</strong>：锁住符合条件的行，提高并发性能（InnoDB 采用行锁）。</li></ul><p>✅ <strong>共享锁（S 锁） vs. 排他锁（X 锁）</strong></p><ul><li><strong>共享锁（S 锁）</strong>：多个事务可以同时读取（<code>SELECT ... LOCK IN SHARE MODE</code>）。</li><li><strong>排他锁（X 锁）</strong>：只允许一个事务修改（<code>SELECT ... FOR UPDATE</code>）。</li></ul><p>✅ <strong>死锁 💀 及解决方案</strong> ❌ <strong>不同事务获取锁的顺序不同</strong>，可能会导致死锁！ 💡 <strong>解决方案</strong>：</p><ul><li><strong>事务按照相同顺序获取锁</strong></li><li><strong>降级隔离级别（如 RR -&gt; RC）</strong></li><li><strong>设置 <code>innodb_lock_wait_timeout</code> 超时时间</strong></li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>sql</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>复制编辑</span></span>\n<span class="line"><span>SHOW ENGINE INNODB STATUS; -- 查看死锁情况</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="_6️⃣-mvcc-多版本并发控制-🌀" tabindex="-1"><a class="header-anchor" href="#_6️⃣-mvcc-多版本并发控制-🌀"><span>6️⃣ <strong>MVCC 多版本并发控制 🌀</strong></span></a></h3><p>✅ <strong>MVCC 关键组成</strong></p><ul><li><strong><code>Undo Log</code></strong>：记录数据修改前的历史版本（回滚日志）。</li><li><strong><code>ReadView</code></strong>：记录事务启动时所有活跃的事务 ID，用于确定数据版本。</li></ul><p>✅ <strong>ReadView 版本判断规则</strong> 1️⃣ 事务 ID <strong>小于最小活跃事务 ID</strong> ✅（可见） 2️⃣ 事务 ID <strong>大于当前事务 ID</strong> ❌（不可见） 3️⃣ 事务 ID <strong>在活跃事务列表中</strong> ❌（不可见）</p><hr><h3 id="_7️⃣-日志系统-📝" tabindex="-1"><a class="header-anchor" href="#_7️⃣-日志系统-📝"><span>7️⃣ <strong>日志系统 📝</strong></span></a></h3><p>✅ <strong>Redo Log（重做日志）</strong> 💾</p><ul><li>记录 <strong>已提交的事务</strong>，保证数据持久性。</li><li><strong>WAL 机制（先写日志再写磁盘）</strong>，提升写入效率。</li></ul><p>✅ <strong>Undo Log（回滚日志）</strong> 🔙</p><ul><li>记录 <strong>数据修改前的版本</strong>，用于事务回滚和 MVCC。</li></ul><p>✅ <strong>Binlog（归档日志）</strong> 🔁</p><ul><li>记录 <strong>所有变更</strong>，用于 <strong>数据恢复、主从复制</strong>。</li></ul><hr><h3 id="_8️⃣-sql-慢查询优化-🏃‍♂️" tabindex="-1"><a class="header-anchor" href="#_8️⃣-sql-慢查询优化-🏃‍♂️"><span>8️⃣ <strong>SQL 慢查询优化 🏃‍♂️</strong></span></a></h3><p>✅ <strong>如何定位慢 SQL？</strong></p><ul><li>使用 <code>EXPLAIN</code> 查看执行计划</li><li><code>SHOW PROCESSLIST</code> 监控执行中的 SQL</li><li><code>SHOW ENGINE INNODB STATUS</code> 查看死锁</li><li><code>slow_query_log</code> 慢查询日志</li></ul><p>✅ <strong>深度分页优化（LIMIT 100000, 10）</strong> ❌ <code>LIMIT M, N</code> 先扫描 M 条记录再丢弃，导致性能低下。 ✅ <strong>方案</strong>：使用 <strong>主键索引优化</strong> 或 <strong>ES 进行分页查询</strong>。</p><hr><p>🎯 <strong>总结：熟练掌握 MySQL 事务、索引优化、SQL 调优、锁机制，是面试的核心竞争力！</strong> 🚀</p>',60)]))}]]),i=JSON.parse('{"path":"/posts/interview/MySQL.html","title":"MySQL","lang":"zh-CN","frontmatter":{"icon":"pen-to-square","date":"2024-03-11T00:00:00.000Z","category":["面试"],"tag":["MySQL"],"description":"MySQL MySQL 面试八股知识点总结 💡 1️⃣ MySQL 底层架构 ✅ 存储结构：MySQL 分为 Server 层 和 存储引擎层，其中 InnoDB 将表结构、数据和索引存储在同一个文件，而 MyISAM 则是分开存储。 ✅ 存储引擎： InnoDB：支持事务（ACID），行级锁，支持外键，使用 B+ 树 实现索引，崩溃后可恢复。 My...","head":[["meta",{"property":"og:url","content":"https://github.com/Mly66/blog/posts/interview/MySQL.html"}],["meta",{"property":"og:site_name","content":"马瑶瑶瑶瑶瑶"}],["meta",{"property":"og:title","content":"MySQL"}],["meta",{"property":"og:description","content":"MySQL MySQL 面试八股知识点总结 💡 1️⃣ MySQL 底层架构 ✅ 存储结构：MySQL 分为 Server 层 和 存储引擎层，其中 InnoDB 将表结构、数据和索引存储在同一个文件，而 MyISAM 则是分开存储。 ✅ 存储引擎： InnoDB：支持事务（ACID），行级锁，支持外键，使用 B+ 树 实现索引，崩溃后可恢复。 My..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-11T13:47:23.000Z"}],["meta",{"property":"article:tag","content":"MySQL"}],["meta",{"property":"article:published_time","content":"2024-03-11T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-11T13:47:23.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"MySQL\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-03-11T00:00:00.000Z\\",\\"dateModified\\":\\"2025-03-11T13:47:23.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.Mly\\",\\"url\\":\\"https://mly66.github.io/blog/\\"}]}"]]},"headers":[{"level":2,"title":"MySQL 面试八股知识点总结 💡","slug":"mysql-面试八股知识点总结-💡","link":"#mysql-面试八股知识点总结-💡","children":[{"level":3,"title":"1️⃣ MySQL 底层架构","slug":"_1️⃣-mysql-底层架构","link":"#_1️⃣-mysql-底层架构","children":[]},{"level":3,"title":"2️⃣ 索引（Index）🚀","slug":"_2️⃣-索引-index-🚀","link":"#_2️⃣-索引-index-🚀","children":[]},{"level":3,"title":"3️⃣ SQL 执行流程与优化","slug":"_3️⃣-sql-执行流程与优化","link":"#_3️⃣-sql-执行流程与优化","children":[]},{"level":3,"title":"4️⃣ 事务（Transaction）⚡","slug":"_4️⃣-事务-transaction-⚡","link":"#_4️⃣-事务-transaction-⚡","children":[]},{"level":3,"title":"5️⃣ MySQL 锁 🔒","slug":"_5️⃣-mysql-锁-🔒","link":"#_5️⃣-mysql-锁-🔒","children":[]},{"level":3,"title":"6️⃣ MVCC 多版本并发控制 🌀","slug":"_6️⃣-mvcc-多版本并发控制-🌀","link":"#_6️⃣-mvcc-多版本并发控制-🌀","children":[]},{"level":3,"title":"7️⃣ 日志系统 📝","slug":"_7️⃣-日志系统-📝","link":"#_7️⃣-日志系统-📝","children":[]},{"level":3,"title":"8️⃣ SQL 慢查询优化 🏃‍♂️","slug":"_8️⃣-sql-慢查询优化-🏃‍♂️","link":"#_8️⃣-sql-慢查询优化-🏃‍♂️","children":[]}]}],"git":{"createdTime":1741700843000,"updatedTime":1741700843000,"contributors":[{"name":"Mly66","email":"3127328609@qq.com","commits":1}]},"readingTime":{"minutes":4.54,"words":1362},"filePathRelative":"posts/interview/MySQL.md","localizedDate":"2024年3月11日","excerpt":"\\n<h2>MySQL 面试八股知识点总结 💡</h2>\\n<h3>1️⃣ <strong>MySQL 底层架构</strong></h3>\\n<p>✅ <strong>存储结构</strong>：MySQL 分为 <strong>Server 层</strong> 和 <strong>存储引擎层</strong>，其中 InnoDB 将表结构、数据和索引存储在同一个文件，而 MyISAM 则是分开存储。\\n✅ <strong>存储引擎</strong>：</p>\\n<ul>\\n<li><strong>InnoDB</strong>：支持事务（ACID），行级锁，支持外键，使用 <strong>B+ 树</strong> 实现索引，崩溃后可恢复。</li>\\n<li><strong>MyISAM</strong>：不支持事务，仅支持表级锁，查询快但不支持数据恢复。</li>\\n<li><strong>Memory</strong>：数据存储在内存中，重启即丢失，适用于临时数据存储。</li>\\n</ul>","autoDesc":true}')}}]);